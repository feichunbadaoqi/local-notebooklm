# Backend Coding Standards (Java/Spring Boot)

**This file is automatically loaded by Claude Code when working in `backend/`.**

## Quick Reference

- [Project Context](#project-context)
- [Interface-Driven Design](#interface-driven-design)
- [Layered Architecture](#layered-architecture)
- [Dependency Injection](#dependency-injection)
- [Error Handling](#error-handling)
- [Naming Conventions](#naming-conventions)
- [Metrics & Observability](#metrics--observability)
- [Elasticsearch Abstraction](#elasticsearch-abstraction)
- [Resilience Patterns](#resilience-patterns)
- [Testing](#testing)
- [Code Quality](#code-quality)
- [Performance](#performance)
- [Security](#security)
- [Development Workflow](#development-workflow)
- [Gradle Commands](#gradle-commands)

## Project Context

**For shared project architecture, API endpoints, and SOLID principles, see [root CLAUDE.md](../CLAUDE.md).**

This file contains Java/Spring Boot specific coding standards for the NotebookLM backend.

**Tech Stack:**
- Spring Boot 4.0.2
- LangChain4j 1.11.0
- SQLite (JPA/Hibernate)
- Elasticsearch 8.12.2
- OpenAI GPT-4o-mini

## Interface-Driven Design

**MANDATORY: All service and repository layers MUST define interfaces.**

### Repository Layer

```java
// ✅ CORRECT: Define interface
public interface SessionRepository extends JpaRepository<Session, Long> {
    Optional<Session> findByIdAndUserId(Long id, String userId);
}

// Implementation is auto-generated by Spring Data
```

### Service Layer

```java
// ✅ CORRECT: Define interface + implementation
public interface SessionService {
    SessionDto createSession(CreateSessionRequest request);
    Optional<SessionDto> getSession(Long id);
}

@Service
@RequiredArgsConstructor
public class SessionServiceImpl implements SessionService {
    private final SessionRepository sessionRepository;

    @Override
    public SessionDto createSession(CreateSessionRequest request) {
        // implementation
    }
}
```

### Why This Matters

1. **Testability**: Mock interfaces in unit tests, not concrete classes
2. **Flexibility**: Swap implementations without changing dependents
3. **Clarity**: Interface defines contract; implementation is detail
4. **Spring Proxying**: AOP/transactions work better with interfaces

### Exceptions (When NOT to Use Interfaces)

- Pure utility/helper classes (static methods only)
- DTOs, entities, configuration classes
- Infrastructure code with no alternative implementations

## Layered Architecture

**CRITICAL: Controllers MUST NOT inject or access repositories directly.**

This is a fundamental SOLID principle violation that leads to:
- Tight coupling between presentation and data layers
- Business logic leaking into controllers
- Inability to change data access without modifying controllers
- Harder testing (can't mock repositories in controller tests)

### Anti-Pattern (WRONG)

```java
@RestController
@RequiredArgsConstructor
public class SessionController {
    private final SessionService sessionService;
    private final DocumentRepository documentRepository;  // ❌ WRONG!
    private final ChatMessageRepository messageRepository;  // ❌ WRONG!

    @GetMapping("/sessions/{id}")
    public ResponseEntity<SessionResponse> getSession(@PathVariable UUID id) {
        Session session = sessionService.getSession(id);
        long documentCount = documentRepository.countBySessionId(id);  // ❌ Business logic in controller!
        long messageCount = messageRepository.countBySessionId(id);  // ❌ Business logic in controller!
        return ResponseEntity.ok(SessionResponse.fromEntity(session, documentCount, messageCount));
    }
}
```

### Correct Pattern

```java
// 1. Define DTO for aggregated data
@Data
@Builder
public class SessionWithStats {
    private Session session;
    private long documentCount;
    private long messageCount;

    public SessionResponse toResponse() {
        return SessionResponse.fromEntity(session, documentCount, messageCount);
    }
}

// 2. Add service method
public interface SessionService {
    SessionWithStats getSessionWithStats(UUID sessionId);
}

@Service
@RequiredArgsConstructor
public class SessionServiceImpl implements SessionService {
    private final SessionRepository sessionRepository;
    private final DocumentRepository documentRepository;  // ✅ Service layer can access repositories
    private final ChatMessageRepository messageRepository;

    @Override
    public SessionWithStats getSessionWithStats(UUID sessionId) {
        Session session = sessionRepository.findById(sessionId)
            .orElseThrow(() -> new SessionNotFoundException(sessionId));
        long documentCount = documentRepository.countBySessionId(sessionId);
        long messageCount = messageRepository.countBySessionId(sessionId);
        return SessionWithStats.builder()
            .session(session)
            .documentCount(documentCount)
            .messageCount(messageCount)
            .build();
    }
}

// 3. Controller uses service only
@RestController
@RequiredArgsConstructor
public class SessionController {
    private final SessionService sessionService;  // ✅ Only inject services

    @GetMapping("/sessions/{id}")
    public ResponseEntity<SessionResponse> getSession(@PathVariable UUID id) {
        SessionWithStats stats = sessionService.getSessionWithStats(id);
        return ResponseEntity.ok(stats.toResponse());
    }
}
```

### Business Validation Rules

- All business validation MUST be in services, not controllers
- Controllers only validate HTTP-level concerns (required parameters, formats)
- Services validate business rules (ownership, state transitions, constraints)

## Dependency Injection

**Use constructor injection with Lombok.**

```java
// ✅ CORRECT: Constructor injection with Lombok
@Service
@RequiredArgsConstructor  // Lombok generates constructor
public class ChatServiceImpl implements ChatService {
    private final SessionRepository sessionRepository;
    private final ChatMessageRepository messageRepository;
    private final OpenAiChatModel chatModel;

    // All dependencies injected via constructor (immutable)
}

// ❌ WRONG: Field injection
@Service
public class ChatServiceImpl implements ChatService {
    @Autowired
    private SessionRepository sessionRepository;  // Mutable, harder to test
}
```

## Error Handling

### Exception Design

```java
// ✅ CORRECT: Specific, actionable exceptions
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resourceType, Long id) {
        super(String.format("%s with id %d not found", resourceType, id));
    }
}

// Use in service
public SessionDto getSession(Long id) {
    return sessionRepository.findById(id)
        .map(sessionMapper::toDto)
        .orElseThrow(() -> new ResourceNotFoundException("Session", id));
}
```

### Global Exception Handler

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ApiError(ex.getMessage(), "NOT_FOUND", UUID.randomUUID().toString()));
    }
}
```

## Naming Conventions

| Element | Pattern | Example |
|---------|---------|---------|
| Interface | Noun/Capability | `SessionService`, `DocumentRepository` |
| Implementation | Interface + "Impl" | `SessionServiceImpl`, `ChatServiceImpl` |
| REST Controller | Resource + "Controller" | `SessionController`, `ChatController` |
| DTO | Purpose + "Request"/"Response"/"Dto" | `CreateSessionRequest`, `SessionDto` |
| Entity | Domain noun | `Session`, `ChatMessage`, `Document` |
| Test | Method + "_when" + Condition | `shouldCreateSession_whenValidRequest()` |
| Constants | UPPER_SNAKE_CASE | `MAX_CHUNK_SIZE`, `DEFAULT_EMBEDDING_MODEL` |

## Package Structure

```
com.flamingo.ai.notebooklm/
├── config/           # Spring configs, Resilience4j, Metrics
├── domain/
│   ├── entity/       # JPA entities
│   ├── enums/        # InteractionMode, MessageRole, DocumentStatus
│   └── repository/   # Spring Data repositories
├── service/
│   ├── session/      # Session management
│   ├── document/     # Upload, parse, chunk
│   ├── chat/         # Chat, compaction, streaming
│   ├── rag/          # Embedding, search, RRF fusion
│   └── memory/       # Memory extraction
├── api/
│   ├── rest/         # REST controllers
│   ├── sse/          # SSE controllers
│   └── dto/          # Request/Response objects
├── elasticsearch/    # ES client, index, queries
└── exception/        # Global error handling
```

## Metrics & Observability

All metrics exported via Micrometer to `/actuator/prometheus`.

**CRITICAL: Use @Timed for ALL service-layer timing. Use manual metrics ONLY for business events.**

### Strategy

1. **Controller Metrics**: Use Spring Boot's built-in `http.server.requests` (DO NOT add custom @Timed)
2. **Service Metrics**: Use `@Timed` annotation (provides count + timing + exception tags automatically)
3. **Business Metrics**: Use manual `Counter`/`Gauge` ONLY for domain events (tokens, documents, extractions)

### Why @Timed for Services?

`@Timed` automatically provides:
- `{metric_name}_seconds_count` - total invocations
- `{metric_name}_seconds_sum` - total time spent
- `{metric_name}_seconds_max` - maximum execution time
- `exception="ClassName"` tag - automatic exception tracking

### Pattern

```java
@Service
@RequiredArgsConstructor
public class ChatServiceImpl implements ChatService {
    private final MeterRegistry meterRegistry;

    @Timed(value = "chat.stream", description = "Time to stream chat response")  // ✅ Automatic timing
    @CircuitBreaker(name = "openai")
    public Flux<StreamChunkResponse> streamChat(UUID sessionId, String message) {
        meterRegistry.counter("chat.messages.generated").increment();  // ✅ Manual counter for business metric
        // @Timed handles timing AND exception tracking automatically
        return flux;
    }
}
```

❌ **Anti-Pattern**: Manual Timer.Sample (verbose, no exception tags)
✅ **Correct**: Use @Timed annotation (automatic timing + exception tracking)

### Controller Metrics (Built-in)

**DO NOT add @Timed to controllers.** Spring Boot's `http.server.requests` provides:
- Request count, duration, max
- Tags: `uri`, `method`, `status`, `exception`

### Understanding @Timed Output

For `@Timed(value = "chat.stream")`, metrics include:
- `chat_stream_seconds_count{exception="none"}` - successful invocations
- `chat_stream_seconds_count{exception="ClassName"}` - failed invocations
- `chat_stream_seconds_sum` - total time spent
- `chat_stream_seconds_max` - maximum execution time

### When to Use Manual Metrics

| Metric Type | Use Case | Example |
|-------------|----------|---------|
| Counter | Business events | `chat.tokens.generated`, `document.uploads.success` |
| Gauge | Current state | `sse.connections.active`, `documents.processing.current` |
| Timer (manual) | NEVER | Use @Timed instead |

**Example:** Use `@Timed` for timing + `meterRegistry.counter()` for business events.

## Elasticsearch Abstraction

**CRITICAL: Use the generic ElasticsearchIndexOperations interface for all Elasticsearch index operations.**

### Architecture

The Elasticsearch abstraction layer provides:
- **Generic Interface**: `ElasticsearchIndexOperations<T, ID>` for type-safe index operations
- **Reusable Pattern**: Support multiple indices with different document types
- **Backward Compatibility**: Convenience methods for existing code
- **Spring Integration**: Proper bean injection and configuration

### When to Create a New Index

Create a new Elasticsearch index when you need to:
1. Store a new document type with different schema
2. Support vector search on a new data source
3. Implement domain-specific search logic
4. Maintain separate indices for different features

### Implementation Pattern

**Step 1: Define Document Model** with required fields (id, embeddings, metadata)

**Step 2: Create Index Service** implementing `ElasticsearchIndexOperations<T, ID>`
- Inject `ElasticsearchIndexService` as delegate
- Implement interface methods (initIndex, indexDocuments, vectorSearch, keywordSearch, deleteBy)
- Add convenience methods for backward compatibility

**Step 3: Use in Services** by injecting the index service interface

### Current Implementation: DocumentChunkIndexService

```java
@Service
public class DocumentChunkIndexService
    implements ElasticsearchIndexOperations<DocumentChunk, String> {

    private final ElasticsearchIndexService delegate;

    // Convenience methods for backward compatibility
    public void indexChunks(List<DocumentChunk> chunks) { ... }
    public List<DocumentChunk> vectorSearch(UUID sessionId, List<Float> queryEmbedding, int topK) { ... }
    public void deleteByDocumentId(UUID documentId) { ... }
}
```

### Benefits

1. **Type Safety**: Generic interface ensures correct document types
2. **Reusability**: Same pattern for all Elasticsearch indices
3. **Testability**: Easy to mock `ElasticsearchIndexOperations<T, ID>`
4. **Backward Compatibility**: Convenience methods preserve existing API
5. **SOLID Compliance**: Depend on abstraction, not concrete implementation
6. **Future-Proof**: Add new indices without modifying existing code

## Resilience Patterns

- **Circuit Breakers**: OpenAI (30% failure threshold), Elasticsearch (50%)
- **Retry**: OpenAI rate limits (3 attempts, exponential backoff)
- **Graceful Degradation**: Return empty results if search fails
- **Error Responses**: Structured `ApiError` with errorId for log correlation

## Testing

- **Coverage**: 80% unit test coverage (JaCoCo enforced)
- **Unit Tests**: JUnit 5 + Mockito
- **Integration Tests**: Testcontainers (Elasticsearch)
- **Naming**: `should{Expected}_when{Condition}`

### Unit Test Example

```java
// ✅ CORRECT: Test behavior, not implementation
@Test
void shouldCreateSession_whenValidRequest() {
    // Given
    CreateSessionRequest request = new CreateSessionRequest("Test Session");
    Session entity = new Session();
    when(sessionRepository.save(any(Session.class))).thenReturn(entity);

    // When
    SessionDto result = sessionService.createSession(request);

    // Then
    assertThat(result).isNotNull();
    verify(sessionRepository).save(any(Session.class));
}

// ❌ WRONG: Testing internal implementation details
@Test
void shouldCallRepositorySaveMethod() {
    sessionService.createSession(request);
    verify(sessionRepository).save(any()); // Tests "how", not "what"
}
```

## Code Quality

- **Format**: Google Java Style (Spotless)
- **Static Analysis**: SpotBugs
- **Style Check**: Checkstyle
- **All checks must pass before committing**

## Performance

- Use `@Transactional` for multi-operation DB workflows
- Fetch collections lazily (avoid N+1 queries)
- Use pagination for large result sets
- Cache expensive computations with `@Cacheable`
- Use async processing for long-running tasks (`@Async`)

## Security

- Validate all user inputs (use `@Valid` + Bean Validation)
- Sanitize file uploads (check MIME types, size limits)
- Use parameterized queries (Spring Data JPA does this automatically)
- Never log sensitive data (passwords, tokens, PII)
- Use HTTPS in production

## Documentation

**When to Add Comments:**
- Complex algorithms or business logic
- Non-obvious workarounds or hacks
- Public API methods (use Javadoc)

**When NOT to Add Comments:**
- Self-explanatory code (prefer better naming)
- Redundant descriptions (e.g., `// Set name` above `setName()`)

```java
// ✅ CORRECT: Explains "why", not "what"
// Use RRF (Reciprocal Rank Fusion) to combine vector and BM25 scores
// Formula: score(d) = Σ 1/(k + rank_i) where k=60 (constant)
double combinedScore = calculateRRFScore(vectorRank, bm25Rank);

// ❌ WRONG: States obvious
// Get the session by ID
Session session = sessionRepository.findById(id);
```

## Common Anti-Patterns to Avoid

| ❌ Anti-Pattern | ✅ Better Approach |
|----------------|-------------------|
| God classes (1000+ lines) | Split into focused classes by responsibility |
| Circular dependencies | Introduce interfaces, use events/mediator pattern |
| Magic numbers/strings | Define named constants |
| Catching generic `Exception` | Catch specific exceptions |
| Returning `null` | Return `Optional<T>` |
| Mutable DTOs | Use immutable records |
| Deep nesting (>3 levels) | Extract methods, use guard clauses |
| Copy-paste code | Extract shared logic to utilities/base classes |

## Dependency Management

**IMPORTANT: Always use the latest stable versions of dependencies.**

### Before Adding/Updating Dependencies

1. Check [Maven Central](https://central.sonatype.com/) or [MVN Repository](https://mvnrepository.com/) for the latest stable version
2. Avoid beta/alpha/RC versions unless specifically required
3. Update the version in `build.gradle` ext block for easy version management

### Current Key Dependencies (keep updated)

| Dependency | Version | Check Latest |
|------------|---------|--------------|
| LangChain4j | 1.11.0 | [Maven Central](https://central.sonatype.com/artifact/dev.langchain4j/langchain4j) |
| Apache Tika | 3.2.3 | [Maven Central](https://central.sonatype.com/artifact/org.apache.tika/tika-core) |
| Testcontainers | 1.20.4 | [Maven Central](https://central.sonatype.com/artifact/org.testcontainers/testcontainers) |
| Elasticsearch Client | 8.12.2 | [Maven Central](https://central.sonatype.com/artifact/co.elastic.clients/elasticsearch-java) |

### When to Update

- Before starting new features that depend on library functionality
- When encountering bugs that may be fixed in newer versions
- During periodic maintenance reviews

## Development Workflow

1. Make code changes
2. Run `./gradlew spotlessApply` to auto-format
3. Run `./gradlew check` to verify tests + quality
4. Review coverage at `build/reports/jacoco/test/html/index.html`
5. Commit only when all checks pass

## Gradle Commands

### Development

```bash
./gradlew bootRun              # Start Spring Boot server
./gradlew build                # Build + test + quality checks
./gradlew test                 # Run unit tests
./gradlew integrationTest      # Run integration tests
./gradlew check                # All checks (test, spotbugs, checkstyle)
./gradlew spotlessApply        # Apply Google Java Format
./gradlew jacocoTestReport     # Generate coverage report (target: 80%)
```

### After Every Code Change

```bash
./gradlew check spotlessCheck  # Tests + FindBugs + style + format
```
