# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**NotebookLM Clone** - A localhost AI-powered knowledge assistant with chat UI, document Q&A, and multiple interaction modes.

| Component | Technology |
|-----------|------------|
| Frontend | Angular 20 with SSR |
| Backend | Spring Boot 4.0.2 + LangChain4j |
| LLM | OpenAI GPT-4o-mini + text-embedding-3-small |
| Storage | SQLite (sessions/chat) + Elasticsearch (vectors) |
| API | REST (CRUD) + SSE (chat streaming) |

**Detailed implementation plan:** See `docs/IMPLEMENTATION_PLAN.md`

## Token Usage Tracking

**IMPORTANT: Always report token usage at the end of every response.**

Format:
```
---
üìä Token Usage (this session):
- Total: X tokens
- Approximate input: ~Y tokens (Z%)
- Approximate output: ~W tokens (V%)
- Input/Output ratio: ~R:1
```

This helps monitor API costs and identify expensive operations. Report even if minimal changes.

## Coding Standards & Best Practices

**CRITICAL: Follow these principles for ALL code written in this project.**

### SOLID Principles

Apply SOLID principles consistently across backend and frontend code:

| Principle | Java/Spring | TypeScript/Angular |
|-----------|-------------|-------------------|
| **S**ingle Responsibility | One service = one business capability | One component/service = one purpose |
| **O**pen/Closed | Use interfaces + strategy pattern | Use abstract classes + composition |
| **L**iskov Substitution | Implementations must honor interface contracts | Derived classes must be substitutable |
| **I**nterface Segregation | Small, focused interfaces (not god interfaces) | Define minimal, role-specific interfaces |
| **D**ependency Inversion | Depend on abstractions (interfaces), not concrete classes | Inject abstractions via constructor |

### Interface-Driven Design (Java/Spring)

**MANDATORY: All service and repository layers MUST define interfaces.**

#### Repository Layer
```java
// ‚úÖ CORRECT: Define interface
public interface SessionRepository extends JpaRepository<Session, Long> {
    Optional<Session> findByIdAndUserId(Long id, String userId);
}

// Implementation is auto-generated by Spring Data
```

#### Service Layer
```java
// ‚úÖ CORRECT: Define interface + implementation
public interface SessionService {
    SessionDto createSession(CreateSessionRequest request);
    Optional<SessionDto> getSession(Long id);
}

@Service
@RequiredArgsConstructor
public class SessionServiceImpl implements SessionService {
    private final SessionRepository sessionRepository;

    @Override
    public SessionDto createSession(CreateSessionRequest request) {
        // implementation
    }
}
```

#### Why This Matters
1. **Testability**: Mock interfaces in unit tests, not concrete classes
2. **Flexibility**: Swap implementations without changing dependents
3. **Clarity**: Interface defines contract; implementation is detail
4. **Spring Proxying**: AOP/transactions work better with interfaces

#### Exceptions (When NOT to Use Interfaces)
- Pure utility/helper classes (static methods only)
- DTOs, entities, configuration classes
- Infrastructure code with no alternative implementations

### TypeScript/Angular Best Practices

#### Component Design
```typescript
// ‚úÖ CORRECT: Smart vs Presentational components
// Smart component (container): Handles logic, state, services
@Component({
  selector: 'app-session-container',
  template: '<app-session-view [session]="session$ | async" (save)="onSave($event)"></app-session-view>'
})
export class SessionContainerComponent {
  session$ = this.sessionService.getSession(this.route.snapshot.params['id']);

  constructor(
    private sessionService: SessionService,
    private route: ActivatedRoute
  ) {}

  onSave(data: SessionData): void {
    this.sessionService.updateSession(data).subscribe();
  }
}

// Presentational component (dumb): Pure, receives @Input, emits @Output
@Component({
  selector: 'app-session-view',
  template: '...'
})
export class SessionViewComponent {
  @Input() session: Session | null = null;
  @Output() save = new EventEmitter<SessionData>();

  // No service injection, no business logic
}
```

#### Service Design
```typescript
// ‚úÖ CORRECT: Define service interface
export interface SessionService {
  getSession(id: string): Observable<Session>;
  createSession(request: CreateSessionRequest): Observable<Session>;
}

@Injectable({ providedIn: 'root' })
export class SessionHttpService implements SessionService {
  constructor(private http: HttpClient) {}

  getSession(id: string): Observable<Session> {
    return this.http.get<Session>(`/api/sessions/${id}`);
  }

  createSession(request: CreateSessionRequest): Observable<Session> {
    return this.http.post<Session>('/api/sessions', request);
  }
}
```

#### RxJS Best Practices
- Use `async` pipe in templates (auto-unsubscribe)
- Never subscribe in services (return Observables)
- Use `takeUntil` for manual subscriptions in components
- Prefer `switchMap` over nested subscriptions
- Use `shareReplay(1)` for shared HTTP calls

### Naming Conventions

#### Java/Spring
| Element | Pattern | Example |
|---------|---------|---------|
| Interface | Noun/Capability | `SessionService`, `DocumentRepository` |
| Implementation | Interface + "Impl" | `SessionServiceImpl`, `ChatServiceImpl` |
| REST Controller | Resource + "Controller" | `SessionController`, `ChatController` |
| DTO | Purpose + "Request"/"Response"/"Dto" | `CreateSessionRequest`, `SessionDto` |
| Entity | Domain noun | `Session`, `ChatMessage`, `Document` |
| Test | Method + "_when" + Condition | `shouldCreateSession_whenValidRequest()` |
| Constants | UPPER_SNAKE_CASE | `MAX_CHUNK_SIZE`, `DEFAULT_EMBEDDING_MODEL` |

#### TypeScript/Angular
| Element | Pattern | Example |
|---------|---------|---------|
| Component | Feature + "Component" | `SessionListComponent`, `ChatBoxComponent` |
| Service | Feature + "Service" | `SessionService`, `RagService` |
| Interface/Type | Noun (no "I" prefix) | `Session`, `ChatMessage`, `DocumentUpload` |
| Observable | Variable + "$" suffix | `session$`, `messages$`, `isLoading$` |
| Constants | UPPER_SNAKE_CASE | `MAX_FILE_SIZE`, `API_BASE_URL` |
| Private members | "_" prefix optional | `_destroyed$`, `_sessionId` |

### Dependency Injection

#### Java/Spring
```java
// ‚úÖ CORRECT: Constructor injection with Lombok
@Service
@RequiredArgsConstructor  // Lombok generates constructor
public class ChatServiceImpl implements ChatService {
    private final SessionRepository sessionRepository;
    private final ChatMessageRepository messageRepository;
    private final OpenAiChatModel chatModel;

    // All dependencies injected via constructor (immutable)
}

// ‚ùå WRONG: Field injection
@Service
public class ChatServiceImpl implements ChatService {
    @Autowired
    private SessionRepository sessionRepository;  // Mutable, harder to test
}
```

#### TypeScript/Angular
```typescript
// ‚úÖ CORRECT: Constructor injection
@Component({ ... })
export class SessionComponent {
  constructor(
    private sessionService: SessionService,
    private router: Router,
    private route: ActivatedRoute
  ) {}
}

// ‚úÖ CORRECT: inject() function (Angular 14+)
@Component({ ... })
export class SessionComponent {
  private sessionService = inject(SessionService);
  private router = inject(Router);
}
```

### Error Handling

#### Java/Spring
```java
// ‚úÖ CORRECT: Specific, actionable exceptions
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resourceType, Long id) {
        super(String.format("%s with id %d not found", resourceType, id));
    }
}

// Use in service
public SessionDto getSession(Long id) {
    return sessionRepository.findById(id)
        .map(sessionMapper::toDto)
        .orElseThrow(() -> new ResourceNotFoundException("Session", id));
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ApiError(ex.getMessage(), "NOT_FOUND", UUID.randomUUID().toString()));
    }
}
```

#### TypeScript/Angular
```typescript
// ‚úÖ CORRECT: Centralized error handling
@Injectable({ providedIn: 'root' })
export class ErrorHandlerService {
  constructor(private snackBar: MatSnackBar) {}

  handle(error: HttpErrorResponse): void {
    const message = error.error?.message || 'An unexpected error occurred';
    this.snackBar.open(message, 'Close', { duration: 5000 });
    console.error('Error:', error);
  }
}

// Use in components
this.sessionService.createSession(request)
  .pipe(catchError(err => {
    this.errorHandler.handle(err);
    return EMPTY;
  }))
  .subscribe(session => { ... });
```

### Layered Architecture

Follow strict layer separation:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Presentation Layer (Controllers)   ‚îÇ  ‚Üê REST/SSE endpoints
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Service Layer (Business Logic)     ‚îÇ  ‚Üê Orchestration, validation
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Repository Layer (Data Access)     ‚îÇ  ‚Üê CRUD operations
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Domain Layer (Entities, DTOs)      ‚îÇ  ‚Üê Data models
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Rules:**
- Controllers call Services (never Repositories directly)
- Services call Repositories and other Services
- Repositories only access database
- No business logic in Controllers or Repositories
- Use DTOs for API requests/responses (never expose Entities directly)

### Code Organization

#### Java Package Structure
```
com.company.project/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ rest/              # REST controllers
‚îÇ   ‚îú‚îÄ‚îÄ sse/               # SSE controllers
‚îÇ   ‚îî‚îÄ‚îÄ dto/               # API DTOs (Request/Response)
‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îú‚îÄ‚îÄ feature/           # One package per feature
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FeatureService.java        # Interface
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FeatureServiceImpl.java    # Implementation
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entity/            # JPA entities
‚îÇ   ‚îú‚îÄ‚îÄ repository/        # Spring Data repositories
‚îÇ   ‚îî‚îÄ‚îÄ enums/             # Domain enums
‚îú‚îÄ‚îÄ config/                # Spring configuration
‚îú‚îÄ‚îÄ exception/             # Custom exceptions + global handler
‚îî‚îÄ‚îÄ util/                  # Utility classes
```

#### Angular Directory Structure
```
src/app/
‚îú‚îÄ‚îÄ core/                  # Singleton services, guards, interceptors
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îî‚îÄ‚îÄ interceptors/
‚îú‚îÄ‚îÄ shared/                # Reusable components, pipes, directives
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ pipes/
‚îÇ   ‚îî‚îÄ‚îÄ directives/
‚îú‚îÄ‚îÄ features/              # Feature modules
‚îÇ   ‚îú‚îÄ‚îÄ session/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/    # Smart + presentational components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/      # Feature-specific services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/        # Interfaces, types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ session.module.ts
‚îÇ   ‚îî‚îÄ‚îÄ chat/
‚îî‚îÄ‚îÄ app.component.ts
```

### Testing Principles

#### Unit Tests (Java)
```java
// ‚úÖ CORRECT: Test behavior, not implementation
@Test
void shouldCreateSession_whenValidRequest() {
    // Given
    CreateSessionRequest request = new CreateSessionRequest("Test Session");
    Session entity = new Session();
    when(sessionRepository.save(any(Session.class))).thenReturn(entity);

    // When
    SessionDto result = sessionService.createSession(request);

    // Then
    assertThat(result).isNotNull();
    verify(sessionRepository).save(any(Session.class));
}

// ‚ùå WRONG: Testing internal implementation details
@Test
void shouldCallRepositorySaveMethod() {
    sessionService.createSession(request);
    verify(sessionRepository).save(any()); // Tests "how", not "what"
}
```

#### Unit Tests (TypeScript/Angular)
```typescript
// ‚úÖ CORRECT: Test component behavior
it('should display error when session load fails', () => {
  const errorResponse = new HttpErrorResponse({ status: 404 });
  sessionService.getSession.mockReturnValue(throwError(() => errorResponse));

  fixture.detectChanges();

  expect(component.errorMessage).toBe('Session not found');
  expect(compiled.querySelector('.error')).toBeTruthy();
});
```

### Documentation

**When to Add Comments:**
- Complex algorithms or business logic
- Non-obvious workarounds or hacks
- Public API methods (use Javadoc/TSDoc)

**When NOT to Add Comments:**
- Self-explanatory code (prefer better naming)
- Redundant descriptions (e.g., `// Set name` above `setName()`)

```java
// ‚úÖ CORRECT: Explains "why", not "what"
// Use RRF (Reciprocal Rank Fusion) to combine vector and BM25 scores
// Formula: score(d) = Œ£ 1/(k + rank_i) where k=60 (constant)
double combinedScore = calculateRRFScore(vectorRank, bm25Rank);

// ‚ùå WRONG: States obvious
// Get the session by ID
Session session = sessionRepository.findById(id);
```

### Performance Considerations

#### Backend (Java/Spring)
- Use `@Transactional` for multi-operation DB workflows
- Fetch collections lazily (avoid N+1 queries)
- Use pagination for large result sets
- Cache expensive computations with `@Cacheable`
- Use async processing for long-running tasks (`@Async`)

#### Frontend (TypeScript/Angular)
- Use `OnPush` change detection for presentational components
- Lazy load feature modules with routing
- Use `trackBy` in `*ngFor` loops
- Unsubscribe from Observables (use `async` pipe or `takeUntil`)
- Debounce user input for search/autocomplete

### Security Best Practices

#### Backend
- Validate all user inputs (use `@Valid` + Bean Validation)
- Sanitize file uploads (check MIME types, size limits)
- Use parameterized queries (Spring Data JPA does this automatically)
- Never log sensitive data (passwords, tokens, PII)
- Use HTTPS in production

#### Frontend
- Sanitize user-generated HTML (Angular does this by default)
- Never trust user input in dynamic templates
- Store sensitive tokens in memory, not localStorage
- Validate file types before upload

### Common Anti-Patterns to Avoid

| ‚ùå Anti-Pattern | ‚úÖ Better Approach |
|----------------|-------------------|
| God classes (1000+ lines) | Split into focused classes by responsibility |
| Circular dependencies | Introduce interfaces, use events/mediator pattern |
| Magic numbers/strings | Define named constants |
| Catching generic `Exception` | Catch specific exceptions |
| Returning `null` | Return `Optional<T>` (Java) or `null` with type guards (TS) |
| Mutable DTOs | Use immutable records (Java) or `readonly` (TypeScript) |
| Deep nesting (>3 levels) | Extract methods, use guard clauses |
| Copy-paste code | Extract shared logic to utilities/base classes |

## Development Environment

**IMPORTANT: This project is developed on Windows with PowerShell.**

### Shell Commands
- Always use PowerShell-compatible syntax
- Use `Get-Content` instead of `cat`
- Use `Remove-Item` instead of `rm`
- Use semicolons (`;`) for command chaining, not `&&`
- Use backticks (`` ` ``) for line continuation, not backslashes (`\`)
- File paths: Use backslashes or forward slashes (both work in PowerShell)
- Use `powershell.exe` or `pwsh` for running .ps1 scripts, not `bash`

### Time/Sleep Commands
- Use `Start-Sleep -Seconds 30` instead of `sleep 30`
- For timeouts in scripts, use PowerShell's timeout mechanisms

### Examples:
```powershell
# PowerShell (CORRECT for this project)
Get-Content file.txt | Select-Object -First 10
Start-Sleep -Seconds 5
Remove-Item -Recurse -Force ./temp
powershell.exe -File script.ps1

# Bash (WRONG for this project)
cat file.txt | head -10
sleep 5
rm -rf ./temp
bash script.sh
```

## Common Commands

### Frontend (`frontend/` directory)
```bash
npm start                      # Dev server at localhost:4200
npm run build                  # Production build
npm test                       # Run Karma/Jasmine tests
npm run serve:ssr:frontend     # Run SSR production server
```

### Backend (`backend/` directory)
```bash
./gradlew bootRun              # Start Spring Boot server
./gradlew build                # Build + test + quality checks
./gradlew test                 # Run unit tests
./gradlew integrationTest      # Run integration tests
./gradlew check                # All checks (test, spotbugs, checkstyle)
./gradlew spotlessApply        # Apply Google Java Format
./gradlew jacocoTestReport     # Generate coverage report (target: 80%)
```

**After every backend code change:**
```bash
./gradlew check spotlessCheck  # Tests + FindBugs + style + format
```

## Architecture

### System Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Angular 20 Frontend                        ‚îÇ
‚îÇ  Chat UI ‚îÇ Document Upload ‚îÇ Mode Selector ‚îÇ Session Mgmt   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ HTTP/SSE
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Spring Boot Backend                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ REST API: /sessions, /documents   SSE: /chat/stream    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Services: Session ‚îÇ Document ‚îÇ Chat ‚îÇ RAG ‚îÇ Memory     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ Resilience: Circuit Breakers (OpenAI, Elasticsearch)   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ LangChain4j: ChatModel ‚îÇ EmbeddingModel ‚îÇ Retriever    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Hybrid RAG: Tika Parse ‚Üí Chunk ‚Üí Embed ‚Üí Vector+BM25   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ                     ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ    SQLite     ‚îÇ     ‚îÇ Elasticsearch ‚îÇ
           ‚îÇ  Sessions     ‚îÇ     ‚îÇ  Vectors      ‚îÇ
           ‚îÇ  ChatMessages ‚îÇ     ‚îÇ  BM25 Index   ‚îÇ
           ‚îÇ  Documents    ‚îÇ     ‚îÇ               ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Why LangChain4j (not LangGraph4j)

LangChain4j is sufficient for our RAG + chat use case. LangGraph4j adds complexity for multi-agent workflows we don't need yet. We can add it later if we need:
- Autonomous multi-step research agents
- Complex retry/fallback logic between LLMs
- Collaborative multi-agent features

### Hybrid RAG Pipeline

1. **Document Ingestion**: Upload ‚Üí Tika Parse ‚Üí Chunk (512 tokens, 50 overlap) ‚Üí Embed ‚Üí Index
2. **Query Processing**: Query ‚Üí Embed ‚Üí Vector Search + BM25 ‚Üí RRF Fusion ‚Üí Context
3. **RRF Formula**: `score(doc) = Œ£ 1/(60 + rank_i)` for each retriever

### Interaction Modes (via System Prompts)

| Mode | Behavior | Retrieval |
|------|----------|-----------|
| EXPLORING | Broad discovery, suggestions | 8 chunks |
| RESEARCH | Precise citations, fact-focused | 4 chunks |
| LEARNING | Socratic method, explanations | 6 chunks |

### Chat History Compaction

- **Sliding window**: Keep last 10 messages in full
- **Trigger**: Total tokens > 3000 or messages > 30
- **Action**: Summarize older messages, store in ChatSummary table

### Data Models (SQLite)

- **Session**: id, title, currentMode, createdAt, updatedAt
- **Document**: id, sessionId, fileName, mimeType, status, chunkCount
- **ChatMessage**: id, sessionId, role, content, tokenCount, isCompacted
- **ChatSummary**: id, sessionId, summaryContent, messageCount
- **Memory**: id, sessionId, memoryContent, memoryType, importance

## API Endpoints

### REST (CRUD Operations)
```
POST   /api/sessions                    Create session
GET    /api/sessions                    List sessions
GET    /api/sessions/{id}               Get session
PUT    /api/sessions/{id}/mode          Change mode
DELETE /api/sessions/{id}               Delete session
POST   /api/sessions/{id}/documents     Upload document
GET    /api/sessions/{id}/messages      Get chat history
POST   /api/sessions/{id}/compact       Force compaction
```

### SSE (Chat Streaming)
```
POST /api/sessions/{id}/chat/stream

Events: token, citation, done, error
```

## Backend Package Structure

```
com.flamingo.ai.notebooklm/
‚îú‚îÄ‚îÄ config/           # Spring configs, Resilience4j, Metrics
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ entity/       # JPA entities
‚îÇ   ‚îú‚îÄ‚îÄ enums/        # InteractionMode, MessageRole, DocumentStatus
‚îÇ   ‚îî‚îÄ‚îÄ repository/   # Spring Data repositories
‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îú‚îÄ‚îÄ session/      # Session management
‚îÇ   ‚îú‚îÄ‚îÄ document/     # Upload, parse, chunk
‚îÇ   ‚îú‚îÄ‚îÄ chat/         # Chat, compaction, streaming
‚îÇ   ‚îú‚îÄ‚îÄ rag/          # Embedding, search, RRF fusion
‚îÇ   ‚îî‚îÄ‚îÄ memory/       # Memory extraction
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ rest/         # REST controllers
‚îÇ   ‚îú‚îÄ‚îÄ sse/          # SSE controllers
‚îÇ   ‚îî‚îÄ‚îÄ dto/          # Request/Response objects
‚îú‚îÄ‚îÄ elasticsearch/    # ES client, index, queries
‚îî‚îÄ‚îÄ exception/        # Global error handling
```

## Metrics & Observability

All metrics exported via Micrometer to `/actuator/prometheus`:

| Category | Key Metrics |
|----------|-------------|
| API | `api_request_duration_seconds`, `api_errors_total` |
| LLM | `llm_request_duration_seconds`, `llm_tokens_used_total` |
| RAG | `rag_retrieval_duration_seconds`, `rag_documents_retrieved` |
| SSE | `sse_connections_active`, `sse_events_sent_total` |

## Resilience

- **Circuit Breakers**: OpenAI (30% failure threshold), Elasticsearch (50%)
- **Retry**: OpenAI rate limits (3 attempts, exponential backoff)
- **Graceful Degradation**: Return empty results if search fails
- **Error Responses**: Structured `ApiError` with errorId for log correlation

## Testing Requirements

- **Coverage**: 80% unit test coverage (JaCoCo enforced)
- **Unit Tests**: JUnit 5 + Mockito
- **Integration Tests**: Testcontainers (Elasticsearch)
- **Naming**: `should{Expected}_when{Condition}`

## Code Quality

- **Format**: Google Java Style (Spotless)
- **Static Analysis**: SpotBugs
- **Style Check**: Checkstyle
- **All checks must pass before committing**

## Dependency Management

**IMPORTANT: Always use the latest stable versions of dependencies.**

### Before Adding/Updating Dependencies:
1. Check [Maven Central](https://central.sonatype.com/) or [MVN Repository](https://mvnrepository.com/) for the latest stable version
2. Avoid beta/alpha/RC versions unless specifically required
3. Update the version in `build.gradle` ext block for easy version management

### Current Key Dependencies (keep updated):
| Dependency | Version | Check Latest |
|------------|---------|--------------|
| LangChain4j | 1.11.0 | [Maven Central](https://central.sonatype.com/artifact/dev.langchain4j/langchain4j) |
| Apache Tika | 3.2.3 | [Maven Central](https://central.sonatype.com/artifact/org.apache.tika/tika-core) |
| Testcontainers | 1.20.4 | [Maven Central](https://central.sonatype.com/artifact/org.testcontainers/testcontainers) |
| Elasticsearch Client | 8.12.2 | [Maven Central](https://central.sonatype.com/artifact/co.elastic.clients/elasticsearch-java) |

### When to Update:
- Before starting new features that depend on library functionality
- When encountering bugs that may be fixed in newer versions
- During periodic maintenance reviews

## Development Workflow

1. Make code changes
2. Run `./gradlew spotlessApply` to auto-format
3. Run `./gradlew check` to verify tests + quality
4. Review coverage at `build/reports/jacoco/test/html/index.html`
5. Commit only when all checks pass

## Git Commit Strategy

**IMPORTANT: Commit code at each finished stage to preserve progress.**

### Commit at These Milestones:
- After completing a logical feature/service (e.g., "Add RAG services")
- After fixing build/test issues
- Before starting a new major component
- When all quality checks pass

### Commit Message Format:
```
<type>: <short description>

<optional body with details>

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`

### Example Workflow:
```bash
# After completing RAG services
./gradlew spotlessApply check
git add -A
git commit -m "feat: add RAG services with hybrid search

- EmbeddingService for OpenAI embeddings
- HybridSearchService with RRF fusion
- DocumentProcessingService with Tika parsing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```
