# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**NotebookLM Clone** - A localhost AI-powered knowledge assistant with chat UI, document Q&A, and multiple interaction modes.

| Component | Technology |
|-----------|------------|
| Frontend | Angular 20 with SSR |
| Backend | Spring Boot 4.0.2 + LangChain4j |
| LLM | OpenAI GPT-4o-mini + text-embedding-3-small |
| Storage | SQLite (sessions/chat) + Elasticsearch (vectors) |
| API | REST (CRUD) + SSE (chat streaming) |

**Detailed implementation plan:** See `docs/IMPLEMENTATION_PLAN.md`

## Coding Standards & Best Practices

**CRITICAL: Follow these principles for ALL code written in this project.**

### SOLID Principles

Apply SOLID principles consistently across backend and frontend code:

| Principle | Java/Spring | TypeScript/Angular |
|-----------|-------------|-------------------|
| **S**ingle Responsibility | One service = one business capability | One component/service = one purpose |
| **O**pen/Closed | Use interfaces + strategy pattern | Use abstract classes + composition |
| **L**iskov Substitution | Implementations must honor interface contracts | Derived classes must be substitutable |
| **I**nterface Segregation | Small, focused interfaces (not god interfaces) | Define minimal, role-specific interfaces |
| **D**ependency Inversion | Depend on abstractions (interfaces), not concrete classes | Inject abstractions via constructor |

### Interface-Driven Design (Java/Spring)

**MANDATORY: All service and repository layers MUST define interfaces.**

#### Repository Layer
```java
// ✅ CORRECT: Define interface
public interface SessionRepository extends JpaRepository<Session, Long> {
    Optional<Session> findByIdAndUserId(Long id, String userId);
}

// Implementation is auto-generated by Spring Data
```

#### Service Layer
```java
// ✅ CORRECT: Define interface + implementation
public interface SessionService {
    SessionDto createSession(CreateSessionRequest request);
    Optional<SessionDto> getSession(Long id);
}

@Service
@RequiredArgsConstructor
public class SessionServiceImpl implements SessionService {
    private final SessionRepository sessionRepository;

    @Override
    public SessionDto createSession(CreateSessionRequest request) {
        // implementation
    }
}
```

#### Why This Matters
1. **Testability**: Mock interfaces in unit tests, not concrete classes
2. **Flexibility**: Swap implementations without changing dependents
3. **Clarity**: Interface defines contract; implementation is detail
4. **Spring Proxying**: AOP/transactions work better with interfaces

#### Exceptions (When NOT to Use Interfaces)
- Pure utility/helper classes (static methods only)
- DTOs, entities, configuration classes
- Infrastructure code with no alternative implementations

### TypeScript/Angular Best Practices

#### Component Design
```typescript
// ✅ CORRECT: Smart vs Presentational components
// Smart component (container): Handles logic, state, services
@Component({
  selector: 'app-session-container',
  template: '<app-session-view [session]="session$ | async" (save)="onSave($event)"></app-session-view>'
})
export class SessionContainerComponent {
  session$ = this.sessionService.getSession(this.route.snapshot.params['id']);

  constructor(
    private sessionService: SessionService,
    private route: ActivatedRoute
  ) {}

  onSave(data: SessionData): void {
    this.sessionService.updateSession(data).subscribe();
  }
}

// Presentational component (dumb): Pure, receives @Input, emits @Output
@Component({
  selector: 'app-session-view',
  template: '...'
})
export class SessionViewComponent {
  @Input() session: Session | null = null;
  @Output() save = new EventEmitter<SessionData>();

  // No service injection, no business logic
}
```

#### Service Design
```typescript
// ✅ CORRECT: Define service interface
export interface SessionService {
  getSession(id: string): Observable<Session>;
  createSession(request: CreateSessionRequest): Observable<Session>;
}

@Injectable({ providedIn: 'root' })
export class SessionHttpService implements SessionService {
  constructor(private http: HttpClient) {}

  getSession(id: string): Observable<Session> {
    return this.http.get<Session>(`/api/sessions/${id}`);
  }

  createSession(request: CreateSessionRequest): Observable<Session> {
    return this.http.post<Session>('/api/sessions', request);
  }
}
```

#### RxJS Best Practices
- Use `async` pipe in templates (auto-unsubscribe)
- Never subscribe in services (return Observables)
- Use `takeUntil` for manual subscriptions in components
- Prefer `switchMap` over nested subscriptions
- Use `shareReplay(1)` for shared HTTP calls

### Naming Conventions

#### Java/Spring
| Element | Pattern | Example |
|---------|---------|---------|
| Interface | Noun/Capability | `SessionService`, `DocumentRepository` |
| Implementation | Interface + "Impl" | `SessionServiceImpl`, `ChatServiceImpl` |
| REST Controller | Resource + "Controller" | `SessionController`, `ChatController` |
| DTO | Purpose + "Request"/"Response"/"Dto" | `CreateSessionRequest`, `SessionDto` |
| Entity | Domain noun | `Session`, `ChatMessage`, `Document` |
| Test | Method + "_when" + Condition | `shouldCreateSession_whenValidRequest()` |
| Constants | UPPER_SNAKE_CASE | `MAX_CHUNK_SIZE`, `DEFAULT_EMBEDDING_MODEL` |

#### TypeScript/Angular
| Element | Pattern | Example |
|---------|---------|---------|
| Component | Feature + "Component" | `SessionListComponent`, `ChatBoxComponent` |
| Service | Feature + "Service" | `SessionService`, `RagService` |
| Interface/Type | Noun (no "I" prefix) | `Session`, `ChatMessage`, `DocumentUpload` |
| Observable | Variable + "$" suffix | `session$`, `messages$`, `isLoading$` |
| Constants | UPPER_SNAKE_CASE | `MAX_FILE_SIZE`, `API_BASE_URL` |
| Private members | "_" prefix optional | `_destroyed$`, `_sessionId` |

### Dependency Injection

#### Java/Spring
```java
// ✅ CORRECT: Constructor injection with Lombok
@Service
@RequiredArgsConstructor  // Lombok generates constructor
public class ChatServiceImpl implements ChatService {
    private final SessionRepository sessionRepository;
    private final ChatMessageRepository messageRepository;
    private final OpenAiChatModel chatModel;

    // All dependencies injected via constructor (immutable)
}

// ❌ WRONG: Field injection
@Service
public class ChatServiceImpl implements ChatService {
    @Autowired
    private SessionRepository sessionRepository;  // Mutable, harder to test
}
```

#### TypeScript/Angular
```typescript
// ✅ CORRECT: Constructor injection
@Component({ ... })
export class SessionComponent {
  constructor(
    private sessionService: SessionService,
    private router: Router,
    private route: ActivatedRoute
  ) {}
}

// ✅ CORRECT: inject() function (Angular 14+)
@Component({ ... })
export class SessionComponent {
  private sessionService = inject(SessionService);
  private router = inject(Router);
}
```

### Error Handling

#### Java/Spring
```java
// ✅ CORRECT: Specific, actionable exceptions
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resourceType, Long id) {
        super(String.format("%s with id %d not found", resourceType, id));
    }
}

// Use in service
public SessionDto getSession(Long id) {
    return sessionRepository.findById(id)
        .map(sessionMapper::toDto)
        .orElseThrow(() -> new ResourceNotFoundException("Session", id));
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiError> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ApiError(ex.getMessage(), "NOT_FOUND", UUID.randomUUID().toString()));
    }
}
```

#### TypeScript/Angular
```typescript
// ✅ CORRECT: Centralized error handling
@Injectable({ providedIn: 'root' })
export class ErrorHandlerService {
  constructor(private snackBar: MatSnackBar) {}

  handle(error: HttpErrorResponse): void {
    const message = error.error?.message || 'An unexpected error occurred';
    this.snackBar.open(message, 'Close', { duration: 5000 });
    console.error('Error:', error);
  }
}

// Use in components
this.sessionService.createSession(request)
  .pipe(catchError(err => {
    this.errorHandler.handle(err);
    return EMPTY;
  }))
  .subscribe(session => { ... });
```

### Layered Architecture

Follow strict layer separation:

```
┌─────────────────────────────────────┐
│  Presentation Layer (Controllers)   │  ← REST/SSE endpoints
├─────────────────────────────────────┤
│  Service Layer (Business Logic)     │  ← Orchestration, validation
├─────────────────────────────────────┤
│  Repository Layer (Data Access)     │  ← CRUD operations
├─────────────────────────────────────┤
│  Domain Layer (Entities, DTOs)      │  ← Data models
└─────────────────────────────────────┘
```

**Rules:**
- Controllers call Services (never Repositories directly)
- Services call Repositories and other Services
- Repositories only access database
- No business logic in Controllers or Repositories
- Use DTOs for API requests/responses (never expose Entities directly)

#### Extended Layering Guidelines

**CRITICAL: Controllers MUST NOT inject or access repositories directly.**

This is a fundamental SOLID principle violation that leads to:
- Tight coupling between presentation and data layers
- Business logic leaking into controllers
- Inability to change data access without modifying controllers
- Harder testing (can't mock repositories in controller tests)

**Anti-Pattern (WRONG):**
```java
@RestController
@RequiredArgsConstructor
public class SessionController {
    private final SessionService sessionService;
    private final DocumentRepository documentRepository;  // ❌ WRONG!
    private final ChatMessageRepository messageRepository;  // ❌ WRONG!

    @GetMapping("/sessions/{id}")
    public ResponseEntity<SessionResponse> getSession(@PathVariable UUID id) {
        Session session = sessionService.getSession(id);
        long documentCount = documentRepository.countBySessionId(id);  // ❌ Business logic in controller!
        long messageCount = messageRepository.countBySessionId(id);  // ❌ Business logic in controller!
        return ResponseEntity.ok(SessionResponse.fromEntity(session, documentCount, messageCount));
    }
}
```

**Correct Pattern:**
```java
// 1. Define DTO for aggregated data
@Data
@Builder
public class SessionWithStats {
    private Session session;
    private long documentCount;
    private long messageCount;

    public SessionResponse toResponse() {
        return SessionResponse.fromEntity(session, documentCount, messageCount);
    }
}

// 2. Add service method
public interface SessionService {
    SessionWithStats getSessionWithStats(UUID sessionId);
}

@Service
@RequiredArgsConstructor
public class SessionServiceImpl implements SessionService {
    private final SessionRepository sessionRepository;
    private final DocumentRepository documentRepository;  // ✅ Service layer can access repositories
    private final ChatMessageRepository messageRepository;

    @Override
    public SessionWithStats getSessionWithStats(UUID sessionId) {
        Session session = sessionRepository.findById(sessionId)
            .orElseThrow(() -> new SessionNotFoundException(sessionId));
        long documentCount = documentRepository.countBySessionId(sessionId);
        long messageCount = messageRepository.countBySessionId(sessionId);
        return SessionWithStats.builder()
            .session(session)
            .documentCount(documentCount)
            .messageCount(messageCount)
            .build();
    }
}

// 3. Controller uses service only
@RestController
@RequiredArgsConstructor
public class SessionController {
    private final SessionService sessionService;  // ✅ Only inject services

    @GetMapping("/sessions/{id}")
    public ResponseEntity<SessionResponse> getSession(@PathVariable UUID id) {
        SessionWithStats stats = sessionService.getSessionWithStats(id);
        return ResponseEntity.ok(stats.toResponse());
    }
}
```

**Business Validation Rules:**
- All business validation MUST be in services, not controllers
- Controllers only validate HTTP-level concerns (required parameters, formats)
- Services validate business rules (ownership, state transitions, constraints)

**Example:**
```java
// ❌ WRONG: Business validation in controller
@DeleteMapping("/memories/{id}")
public ResponseEntity<Void> deleteMemory(@PathVariable UUID id, @RequestParam UUID sessionId) {
    Memory memory = memoryRepository.findById(id)
        .orElseThrow(() -> new MemoryNotFoundException(id));
    if (!memory.getSession().getId().equals(sessionId)) {  // ❌ Business logic!
        throw new MemoryAccessDeniedException();
    }
    memoryService.deleteMemory(id);
    return ResponseEntity.noContent().build();
}

// ✅ CORRECT: Business validation in service
@DeleteMapping("/memories/{id}")
public ResponseEntity<Void> deleteMemory(@PathVariable UUID id, @RequestParam UUID sessionId) {
    memoryService.validateMemoryOwnership(id, sessionId);  // ✅ Service validates
    memoryService.deleteMemory(id);
    return ResponseEntity.noContent().build();
}
```

### Code Organization

#### Java Package Structure
```
com.company.project/
├── api/
│   ├── rest/              # REST controllers
│   ├── sse/               # SSE controllers
│   └── dto/               # API DTOs (Request/Response)
├── service/
│   ├── feature/           # One package per feature
│   │   ├── FeatureService.java        # Interface
│   │   └── FeatureServiceImpl.java    # Implementation
├── domain/
│   ├── entity/            # JPA entities
│   ├── repository/        # Spring Data repositories
│   └── enums/             # Domain enums
├── config/                # Spring configuration
├── exception/             # Custom exceptions + global handler
└── util/                  # Utility classes
```

#### Angular Directory Structure
```
src/app/
├── core/                  # Singleton services, guards, interceptors
│   ├── services/
│   ├── guards/
│   └── interceptors/
├── shared/                # Reusable components, pipes, directives
│   ├── components/
│   ├── pipes/
│   └── directives/
├── features/              # Feature modules
│   ├── session/
│   │   ├── components/    # Smart + presentational components
│   │   ├── services/      # Feature-specific services
│   │   ├── models/        # Interfaces, types
│   │   └── session.module.ts
│   └── chat/
└── app.component.ts
```

### Testing Principles

#### Unit Tests (Java)
```java
// ✅ CORRECT: Test behavior, not implementation
@Test
void shouldCreateSession_whenValidRequest() {
    // Given
    CreateSessionRequest request = new CreateSessionRequest("Test Session");
    Session entity = new Session();
    when(sessionRepository.save(any(Session.class))).thenReturn(entity);

    // When
    SessionDto result = sessionService.createSession(request);

    // Then
    assertThat(result).isNotNull();
    verify(sessionRepository).save(any(Session.class));
}

// ❌ WRONG: Testing internal implementation details
@Test
void shouldCallRepositorySaveMethod() {
    sessionService.createSession(request);
    verify(sessionRepository).save(any()); // Tests "how", not "what"
}
```

#### Unit Tests (TypeScript/Angular)
```typescript
// ✅ CORRECT: Test component behavior
it('should display error when session load fails', () => {
  const errorResponse = new HttpErrorResponse({ status: 404 });
  sessionService.getSession.mockReturnValue(throwError(() => errorResponse));

  fixture.detectChanges();

  expect(component.errorMessage).toBe('Session not found');
  expect(compiled.querySelector('.error')).toBeTruthy();
});
```

### Documentation

**When to Add Comments:**
- Complex algorithms or business logic
- Non-obvious workarounds or hacks
- Public API methods (use Javadoc/TSDoc)

**When NOT to Add Comments:**
- Self-explanatory code (prefer better naming)
- Redundant descriptions (e.g., `// Set name` above `setName()`)

```java
// ✅ CORRECT: Explains "why", not "what"
// Use RRF (Reciprocal Rank Fusion) to combine vector and BM25 scores
// Formula: score(d) = Σ 1/(k + rank_i) where k=60 (constant)
double combinedScore = calculateRRFScore(vectorRank, bm25Rank);

// ❌ WRONG: States obvious
// Get the session by ID
Session session = sessionRepository.findById(id);
```

### Performance Considerations

#### Backend (Java/Spring)
- Use `@Transactional` for multi-operation DB workflows
- Fetch collections lazily (avoid N+1 queries)
- Use pagination for large result sets
- Cache expensive computations with `@Cacheable`
- Use async processing for long-running tasks (`@Async`)

#### Frontend (TypeScript/Angular)
- Use `OnPush` change detection for presentational components
- Lazy load feature modules with routing
- Use `trackBy` in `*ngFor` loops
- Unsubscribe from Observables (use `async` pipe or `takeUntil`)
- Debounce user input for search/autocomplete

### Security Best Practices

#### Backend
- Validate all user inputs (use `@Valid` + Bean Validation)
- Sanitize file uploads (check MIME types, size limits)
- Use parameterized queries (Spring Data JPA does this automatically)
- Never log sensitive data (passwords, tokens, PII)
- Use HTTPS in production

#### Frontend
- Sanitize user-generated HTML (Angular does this by default)
- Never trust user input in dynamic templates
- Store sensitive tokens in memory, not localStorage
- Validate file types before upload

### Common Anti-Patterns to Avoid

| ❌ Anti-Pattern | ✅ Better Approach |
|----------------|-------------------|
| God classes (1000+ lines) | Split into focused classes by responsibility |
| Circular dependencies | Introduce interfaces, use events/mediator pattern |
| Magic numbers/strings | Define named constants |
| Catching generic `Exception` | Catch specific exceptions |
| Returning `null` | Return `Optional<T>` (Java) or `null` with type guards (TS) |
| Mutable DTOs | Use immutable records (Java) or `readonly` (TypeScript) |
| Deep nesting (>3 levels) | Extract methods, use guard clauses |
| Copy-paste code | Extract shared logic to utilities/base classes |

## Development Environment

**IMPORTANT: This project is developed on Windows with PowerShell.**

### Shell Commands
- Always use PowerShell-compatible syntax
- Use `Get-Content` instead of `cat`
- Use `Remove-Item` instead of `rm`
- Use semicolons (`;`) for command chaining, not `&&`
- Use backticks (`` ` ``) for line continuation, not backslashes (`\`)
- File paths: Use backslashes or forward slashes (both work in PowerShell)
- Use `powershell.exe` or `pwsh` for running .ps1 scripts, not `bash`

### Time/Sleep Commands
- Use `Start-Sleep -Seconds 30` instead of `sleep 30`
- For timeouts in scripts, use PowerShell's timeout mechanisms

### Examples:
```powershell
# PowerShell (CORRECT for this project)
Get-Content file.txt | Select-Object -First 10
Start-Sleep -Seconds 5
Remove-Item -Recurse -Force ./temp
powershell.exe -File script.ps1

# Bash (WRONG for this project)
cat file.txt | head -10
sleep 5
rm -rf ./temp
bash script.sh
```

## Common Commands

### Frontend (`frontend/` directory)
```bash
npm start                      # Dev server at localhost:4200
npm run build                  # Production build
npm test                       # Run Karma/Jasmine tests
npm run serve:ssr:frontend     # Run SSR production server
```

### Backend (`backend/` directory)
```bash
./gradlew bootRun              # Start Spring Boot server
./gradlew build                # Build + test + quality checks
./gradlew test                 # Run unit tests
./gradlew integrationTest      # Run integration tests
./gradlew check                # All checks (test, spotbugs, checkstyle)
./gradlew spotlessApply        # Apply Google Java Format
./gradlew jacocoTestReport     # Generate coverage report (target: 80%)
```

**After every backend code change:**
```bash
./gradlew check spotlessCheck  # Tests + FindBugs + style + format
```

## Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────────┐
│                   Angular 20 Frontend                        │
│  Chat UI │ Document Upload │ Mode Selector │ Session Mgmt   │
└─────────────────────────────────┬───────────────────────────┘
                                  │ HTTP/SSE
┌─────────────────────────────────┴───────────────────────────┐
│                 Spring Boot Backend                          │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ REST API: /sessions, /documents   SSE: /chat/stream    │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Services: Session │ Document │ Chat │ RAG │ Memory     │ │
│  │ Resilience: Circuit Breakers (OpenAI, Elasticsearch)   │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ LangChain4j: ChatModel │ EmbeddingModel │ Retriever    │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ Hybrid RAG: Tika Parse → Chunk → Embed → Vector+BM25   │ │
│  └────────────────────────────────────────────────────────┘ │
└──────────────────┬─────────────────────┬────────────────────┘
                   │                     │
           ┌───────┴───────┐     ┌───────┴───────┐
           │    SQLite     │     │ Elasticsearch │
           │  Sessions     │     │  Vectors      │
           │  ChatMessages │     │  BM25 Index   │
           │  Documents    │     │               │
           └───────────────┘     └───────────────┘
```

### Why LangChain4j (not LangGraph4j)

LangChain4j is sufficient for our RAG + chat use case. LangGraph4j adds complexity for multi-agent workflows we don't need yet. We can add it later if we need:
- Autonomous multi-step research agents
- Complex retry/fallback logic between LLMs
- Collaborative multi-agent features

### Hybrid RAG Pipeline

1. **Document Ingestion**: Upload → Tika Parse → Chunk (512 tokens, 50 overlap) → Embed → Index
2. **Query Processing**: Query → Embed → Vector Search + BM25 → RRF Fusion → Context
3. **RRF Formula**: `score(doc) = Σ 1/(60 + rank_i)` for each retriever

### Interaction Modes (via System Prompts)

| Mode | Behavior | Retrieval |
|------|----------|-----------|
| EXPLORING | Broad discovery, suggestions | 8 chunks |
| RESEARCH | Precise citations, fact-focused | 4 chunks |
| LEARNING | Socratic method, explanations | 6 chunks |

### Chat History Compaction

- **Sliding window**: Keep last 10 messages in full
- **Trigger**: Total tokens > 3000 or messages > 30
- **Action**: Summarize older messages, store in ChatSummary table

### Data Models (SQLite)

- **Session**: id, title, currentMode, createdAt, updatedAt
- **Document**: id, sessionId, fileName, mimeType, status, chunkCount
- **ChatMessage**: id, sessionId, role, content, tokenCount, isCompacted
- **ChatSummary**: id, sessionId, summaryContent, messageCount
- **Memory**: id, sessionId, memoryContent, memoryType, importance

## API Endpoints

### REST (CRUD Operations)
```
POST   /api/sessions                    Create session
GET    /api/sessions                    List sessions
GET    /api/sessions/{id}               Get session
PUT    /api/sessions/{id}/mode          Change mode
DELETE /api/sessions/{id}               Delete session
POST   /api/sessions/{id}/documents     Upload document
GET    /api/sessions/{id}/messages      Get chat history
POST   /api/sessions/{id}/compact       Force compaction
```

### SSE (Chat Streaming)
```
POST /api/sessions/{id}/chat/stream

Events: token, citation, done, error
```

## Backend Package Structure

```
com.flamingo.ai.notebooklm/
├── config/           # Spring configs, Resilience4j, Metrics
├── domain/
│   ├── entity/       # JPA entities
│   ├── enums/        # InteractionMode, MessageRole, DocumentStatus
│   └── repository/   # Spring Data repositories
├── service/
│   ├── session/      # Session management
│   ├── document/     # Upload, parse, chunk
│   ├── chat/         # Chat, compaction, streaming
│   ├── rag/          # Embedding, search, RRF fusion
│   └── memory/       # Memory extraction
├── api/
│   ├── rest/         # REST controllers
│   ├── sse/          # SSE controllers
│   └── dto/          # Request/Response objects
├── elasticsearch/    # ES client, index, queries
└── exception/        # Global error handling
```

## Metrics & Observability

All metrics exported via Micrometer to `/actuator/prometheus`:

| Category | Key Metrics |
|----------|-------------|
| API | `api_request_duration_seconds`, `api_errors_total` |
| LLM | `llm_request_duration_seconds`, `llm_tokens_used_total` |
| RAG | `rag_retrieval_duration_seconds`, `rag_documents_retrieved` |
| SSE | `sse_connections_active`, `sse_events_sent_total` |

### Metrics Standardization

**CRITICAL: Use @Timed for ALL service-layer timing. Use manual metrics ONLY for business events.**

#### Strategy:

1. **Controller Metrics**: Use Spring Boot's built-in `http.server.requests` (DO NOT add custom @Timed)
2. **Service Metrics**: Use `@Timed` annotation (provides count + timing + exception tags automatically)
3. **Business Metrics**: Use manual `Counter`/`Gauge` ONLY for domain events (tokens, documents, extractions)

#### Why @Timed for Services?

`@Timed` automatically provides:
- `{metric_name}_seconds_count` - total invocations
- `{metric_name}_seconds_sum` - total time spent
- `{metric_name}_seconds_max` - maximum execution time
- `exception="ClassName"` tag - automatic exception tracking

**Anti-Pattern (WRONG - Manual Timer.Sample):**
```java
@Service
@RequiredArgsConstructor
public class ChatServiceImpl implements ChatService {
    private final MeterRegistry meterRegistry;

    public Flux<StreamChunkResponse> streamChat(UUID sessionId, String message) {
        Timer.Sample sample = Timer.start(meterRegistry);  // ❌ Manual timing
        try {
            // ... implementation
            return flux;
        } finally {
            sample.stop(meterRegistry.timer("chat.stream.duration"));  // ❌ Verbose, no exception tags
        }
    }
}
```

**Correct Pattern:**
```java
@Service
@RequiredArgsConstructor
public class ChatServiceImpl implements ChatService {
    private final MeterRegistry meterRegistry;

    @Timed(value = "chat.stream", description = "Time to stream chat response")  // ✅ Automatic timing
    @CircuitBreaker(name = "openai")
    public Flux<StreamChunkResponse> streamChat(UUID sessionId, String message) {
        // ... implementation
        // @Timed handles timing AND exception tracking automatically
        meterRegistry.counter("chat.messages.generated").increment();  // ✅ Manual counter for business metric
        return flux;
    }
}
```

#### Controller Metrics (Built-in)

**DO NOT add @Timed to controllers.** Spring Boot's `http.server.requests` provides:
- Request count, duration, max
- Tags: `uri`, `method`, `status`, `exception`

**Prometheus Queries:**
```promql
# Request rate (requests per second)
rate(http_server_requests_seconds_count[5m])

# Error rate (5xx errors per second)
rate(http_server_requests_seconds_count{status=~"5.."}[5m])

# P95 latency by endpoint
histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[5m]))

# Error rate per endpoint
sum by (uri, method) (rate(http_server_requests_seconds_count{status=~"5.."}[5m]))
```

#### Understanding @Timed Output

For `@Timed(value = "chat.stream")`:
```
chat_stream_seconds_count{exception="none"} 150
chat_stream_seconds_count{exception="OpenAiException"} 5
chat_stream_seconds_sum{exception="none"} 45.2
chat_stream_seconds_max{exception="none"} 2.1
```

**Prometheus Queries:**
```promql
# Total chat requests
sum(chat_stream_seconds_count)

# Chat error rate
sum(rate(chat_stream_seconds_count{exception!="none"}[5m]))

# Chat success rate
sum(rate(chat_stream_seconds_count{exception="none"}[5m]))

# Average chat latency
rate(chat_stream_seconds_sum[5m]) / rate(chat_stream_seconds_count[5m])
```

#### When to Use Manual Metrics

Use manual `Counter`/`Gauge` ONLY for business-specific metrics:

| Metric Type | Use Case | Example |
|-------------|----------|---------|
| Counter | Business events | `chat.tokens.generated`, `document.uploads.success`, `memory.extractions.count` |
| Gauge | Current state | `sse.connections.active`, `documents.processing.current` |
| Timer (manual) | NEVER | Use @Timed instead |

**Example - Correct Mix:**
```java
@Service
@RequiredArgsConstructor
public class EmbeddingService {
    private final MeterRegistry meterRegistry;
    private final EmbeddingModel embeddingModel;

    @Timed(value = "embedding.embed", description = "Time to embed text")  // ✅ Timing via @Timed
    @CircuitBreaker(name = "openai")
    public List<Float> embedText(String text) {
        try {
            Response<Embedding> response = embeddingModel.embed(text);
            meterRegistry.counter("embedding.requests.success").increment();  // ✅ Business counter
            return response.content().vector();
        } catch (Exception e) {
            meterRegistry.counter("embedding.requests.failure").increment();  // ✅ Business counter
            throw e;  // @Timed will tag with exception="ClassName"
        }
    }
}
```

#### TimedAspect Configuration

Ensure `TimedAspect` is registered in your configuration:

```java
@Configuration
public class MetricsConfig {
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}
```

## Resilience

- **Circuit Breakers**: OpenAI (30% failure threshold), Elasticsearch (50%)
- **Retry**: OpenAI rate limits (3 attempts, exponential backoff)
- **Graceful Degradation**: Return empty results if search fails
- **Error Responses**: Structured `ApiError` with errorId for log correlation

## Elasticsearch Abstraction

**CRITICAL: Use the generic ElasticsearchIndexOperations interface for all Elasticsearch index operations.**

### Architecture

The Elasticsearch abstraction layer provides:
- **Generic Interface**: `ElasticsearchIndexOperations<T, ID>` for type-safe index operations
- **Reusable Pattern**: Support multiple indices with different document types
- **Backward Compatibility**: Convenience methods for existing code
- **Spring Integration**: Proper bean injection and configuration

### When to Create a New Index

Create a new Elasticsearch index when you need to:
1. Store a new document type with different schema
2. Support vector search on a new data source
3. Implement domain-specific search logic
4. Maintain separate indices for different features

### Implementation Guide

#### Step 1: Define Your Document Model

```java
@Data
@Builder
public class KnowledgeArticle {
    private String id;
    private UUID organizationId;
    private String title;
    private String content;
    private List<String> tags;
    private List<Float> embedding;
    private int tokenCount;
    private LocalDateTime publishedAt;
}
```

#### Step 2: Create Index Service

```java
package com.company.project.elasticsearch;

import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;
import java.util.*;

@Service
@Slf4j
public class KnowledgeArticleIndexService
    implements ElasticsearchIndexOperations<KnowledgeArticle, String> {

    private final ElasticsearchIndexService delegate;  // Inject existing bean

    public KnowledgeArticleIndexService(ElasticsearchIndexService elasticsearchIndexService) {
        this.delegate = elasticsearchIndexService;
        // Note: ElasticsearchIndexService is configured for DocumentChunk
        // For KnowledgeArticle, you'd create a new base service or use a different approach
        // This example shows the pattern
    }

    @Override
    public void initIndex() {
        // Initialize knowledge-articles index with schema
        delegate.initIndex();
    }

    @Override
    public void indexDocuments(List<KnowledgeArticle> articles) {
        // Convert to Elasticsearch format and index
        delegate.indexChunks(convertToChunks(articles));
    }

    @Override
    public List<KnowledgeArticle> vectorSearch(
            Map<String, Object> filterCriteria,
            List<Float> queryEmbedding,
            int topK) {
        UUID orgId = (UUID) filterCriteria.get("organizationId");
        if (orgId == null) {
            throw new IllegalArgumentException("organizationId filter required");
        }
        return delegate.vectorSearch(orgId, queryEmbedding, topK)
            .stream()
            .map(this::convertToArticle)
            .toList();
    }

    @Override
    public List<KnowledgeArticle> keywordSearch(
            Map<String, Object> filterCriteria,
            String query,
            int topK) {
        UUID orgId = (UUID) filterCriteria.get("organizationId");
        return delegate.keywordSearch(orgId, query, topK)
            .stream()
            .map(this::convertToArticle)
            .toList();
    }

    @Override
    public void deleteBy(Map<String, Object> criteria) {
        if (criteria.containsKey("articleId")) {
            delegate.deleteByDocumentId((UUID) criteria.get("articleId"));
        } else if (criteria.containsKey("organizationId")) {
            delegate.deleteBySessionId((UUID) criteria.get("organizationId"));
        }
    }

    @Override
    public void refresh() {
        delegate.refresh();
    }

    @Override
    public String getIndexName() {
        return "knowledge-articles";
    }

    // Convenience methods for backward compatibility
    public void indexArticles(List<KnowledgeArticle> articles) {
        indexDocuments(articles);
    }

    public List<KnowledgeArticle> searchByOrganization(
            UUID orgId,
            List<Float> queryEmbedding,
            int topK) {
        Map<String, Object> criteria = Map.of("organizationId", orgId);
        return vectorSearch(criteria, queryEmbedding, topK);
    }

    private List<DocumentChunk> convertToChunks(List<KnowledgeArticle> articles) {
        // Conversion logic
        return Collections.emptyList();
    }

    private KnowledgeArticle convertToArticle(DocumentChunk chunk) {
        // Conversion logic
        return null;
    }
}
```

#### Step 3: Use in Services

```java
@Service
@RequiredArgsConstructor
public class KnowledgeSearchService {
    private final KnowledgeArticleIndexService articleIndexService;
    private final EmbeddingService embeddingService;

    public List<KnowledgeArticle> searchArticles(UUID orgId, String query, int topK) {
        List<Float> embedding = embeddingService.embedText(query);
        return articleIndexService.searchByOrganization(orgId, embedding, topK);
    }
}
```

### Current Implementation: DocumentChunkIndexService

The project uses `DocumentChunkIndexService` as a wrapper around `ElasticsearchIndexService`:

```java
@Service
public class DocumentChunkIndexService
    implements ElasticsearchIndexOperations<DocumentChunk, String> {

    private final ElasticsearchIndexService delegate;

    public DocumentChunkIndexService(ElasticsearchIndexService elasticsearchIndexService) {
        this.delegate = elasticsearchIndexService;  // Inject existing bean
    }

    // Convenience methods for backward compatibility
    public void indexChunks(List<DocumentChunk> chunks) {
        indexDocuments(chunks);
    }

    public List<DocumentChunk> vectorSearch(UUID sessionId, List<Float> queryEmbedding, int topK) {
        Map<String, Object> criteria = Map.of("sessionId", sessionId);
        return vectorSearch(criteria, queryEmbedding, topK);
    }

    public void deleteByDocumentId(UUID documentId) {
        Map<String, Object> criteria = Map.of("documentId", documentId);
        deleteBy(criteria);
    }
}
```

### Benefits

1. **Type Safety**: Generic interface ensures correct document types
2. **Reusability**: Same pattern for all Elasticsearch indices
3. **Testability**: Easy to mock `ElasticsearchIndexOperations<T, ID>`
4. **Backward Compatibility**: Convenience methods preserve existing API
5. **SOLID Compliance**: Depend on abstraction, not concrete implementation
6. **Future-Proof**: Add new indices without modifying existing code

### Testing with Abstraction

```java
@ExtendWith(MockitoExtension.class)
class KnowledgeSearchServiceTest {
    @Mock
    private ElasticsearchIndexOperations<KnowledgeArticle, String> articleIndexService;

    @Mock
    private EmbeddingService embeddingService;

    private KnowledgeSearchService searchService;

    @BeforeEach
    void setUp() {
        searchService = new KnowledgeSearchService(
            (KnowledgeArticleIndexService) articleIndexService,  // Mock via interface
            embeddingService
        );
    }

    @Test
    void shouldSearchArticlesByOrganization() {
        // Mock interface methods, not concrete implementation
        when(articleIndexService.vectorSearch(any(), any(), anyInt()))
            .thenReturn(List.of(createArticle()));

        List<KnowledgeArticle> results = searchService.searchArticles(orgId, "query", 10);

        assertThat(results).isNotEmpty();
    }
}
```

## Testing Requirements

- **Coverage**: 80% unit test coverage (JaCoCo enforced)
- **Unit Tests**: JUnit 5 + Mockito
- **Integration Tests**: Testcontainers (Elasticsearch)
- **Naming**: `should{Expected}_when{Condition}`

## Code Quality

- **Format**: Google Java Style (Spotless)
- **Static Analysis**: SpotBugs
- **Style Check**: Checkstyle
- **All checks must pass before committing**

## Dependency Management

**IMPORTANT: Always use the latest stable versions of dependencies.**

### Before Adding/Updating Dependencies:
1. Check [Maven Central](https://central.sonatype.com/) or [MVN Repository](https://mvnrepository.com/) for the latest stable version
2. Avoid beta/alpha/RC versions unless specifically required
3. Update the version in `build.gradle` ext block for easy version management

### Current Key Dependencies (keep updated):
| Dependency | Version | Check Latest |
|------------|---------|--------------|
| LangChain4j | 1.11.0 | [Maven Central](https://central.sonatype.com/artifact/dev.langchain4j/langchain4j) |
| Apache Tika | 3.2.3 | [Maven Central](https://central.sonatype.com/artifact/org.apache.tika/tika-core) |
| Testcontainers | 1.20.4 | [Maven Central](https://central.sonatype.com/artifact/org.testcontainers/testcontainers) |
| Elasticsearch Client | 8.12.2 | [Maven Central](https://central.sonatype.com/artifact/co.elastic.clients/elasticsearch-java) |

### When to Update:
- Before starting new features that depend on library functionality
- When encountering bugs that may be fixed in newer versions
- During periodic maintenance reviews

## Development Workflow

1. Make code changes
2. Run `./gradlew spotlessApply` to auto-format
3. Run `./gradlew check` to verify tests + quality
4. Review coverage at `build/reports/jacoco/test/html/index.html`
5. Commit only when all checks pass

## Git Commit Strategy

**IMPORTANT: Commit code at each finished stage to preserve progress.**

### Commit at These Milestones:
- After completing a logical feature/service (e.g., "Add RAG services")
- After fixing build/test issues
- Before starting a new major component
- When all quality checks pass

### Commit Message Format:
```
<type>: <short description>

<optional body with details>

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

Types: `feat`, `fix`, `refactor`, `test`, `docs`, `chore`

### Example Workflow:
```bash
# After completing RAG services
./gradlew spotlessApply check
git add -A
git commit -m "feat: add RAG services with hybrid search

- EmbeddingService for OpenAI embeddings
- HybridSearchService with RRF fusion
- DocumentProcessingService with Tika parsing

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```
